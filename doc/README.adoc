= Afterglow Documentation
James Elliott <james@deepsymmetry.org>
:icons: font

// Set up support for relative links on GitHub; add more conditions
// if you need to support other environments and extensions.
ifdef::env-github[:outfilesuffix: .adoc]

To keep page sizes manageable, this information is split into several
pages. This page provides an <<what-is-afterglow,introduction>> and
overview, and links to other sections as needed. If you know what you
are looking for, you can also dive right into it by jumping to the
page you want:

****

[horizontal]
 <<effect_functions#effect-functions,Effect Functions>>::
The building blocks of a dynamic light show, which have a
<<effect_functions#lifecycle,lifecyle>> worth understanding, and a few
<<effect_functions#effect-examples,examples>> to get you started.

<<metronomes#metronomes,Metronomes>>:: Keep track of musical time, in
terms of beats, bars, and phrases, and can be
<<mapping_sync#midi-mapping-and-beat-sync,synced>> to DJ equipment and
software.

<<oscillators#oscillators,Oscillators>>:: Convert show timing
information into waveforms that can drive your light show.

<<show_space#show-space,Show Space>>:: Explores how to measure
locations and orientations when hanging your lights so that Afterglow
can properly calculate spatial and directional effects.

<<rendering_loop#the-rendering-loop,The Rendering Loop>>:: Explains in
detail how a frame of lighting control data is calculated and sent to
the lights in the show.

****

== What is Afterglow?

Afterglow is a functional lighting controller, written in
http://clojure.org[Clojure], intended to enable people to produce
spectacular light shows using modern stage and effect lighting, and
which are related in deep ways to the phrasing of music being played.
(Its http://deepsymmetry.org[creator] is a DJ and producer of light
and laser shows by avocation.) Currently, the
<<effect_functions#effect-functions,lighting effects>> and
<<fixture_definitions#fixture-definitions,fixture definitions>> are
written and organized through Clojure code, so you will either need to
learn Clojure or work with a Clojure programmer to create new ones,
but they are controlled through MIDI control surfaces or Open Sound
Control, so once they are set up, there is great flexibility in how
you can perform them.

Someday a user interface for building shows and fixture definitions may
be created, either within Afterglow, or as a companion project, but that
is not currently planned.

NOTE: Actually, that is a bit of a fib... James has an Ableton Push
and is already exploring how to build a rich interface using its LCD
display, color-changing pressure-sensitive pads, and touch-sensitive
encoders, but that is slightly separate from the main Afterglow
project.


== How Afterglow Works

The fundamental task of Afterglow is to make light shows happen. It
does this by controlling lights, communicating with them through the
https://www.openlighting.org/ola/[Open Lighting Architecture], which
can work with several kinds of control protocols, most of which are
derived from http://en.wikipedia.org/wiki/DMX512[DMX512], or a faster
implementation of its basic ideas over Ethernet. When a show is
running, Afterglow runs a thread which periodically asks “what should
all the lights be doing now?” (resulting in a single “frame” of
control values representing that moment in time), and sends the
results of that analysis to all of the OLA universes the show is
configured to control. By default this happens thirty times each
second, but the interval is configurable within the show, and should
be decided based on the fastest refresh rate of any physical
interfaces you have hooked up to Afterglow. This is described in more
detail in the
<<rendering_loop#the-rendering-loop,Rendering Loop>> section.

TIP: In principle you could have more than one show running at a time, each
controlling a different set of OLA universes, but most people will not
need this capability.

When you just create a show and call `(show/start!)`, Afterglow will
send a bunch of zero values to the show’s universes. To make
interesting things happen you add
<<effect_functions#effect-functions,Effect Functions>> to the show.
The default namespace you are put into when you launch the Afterglow
project using `lein repl` has some
<<effect_functions#effect-examples,example effects>>
that can help get a feel for this concept. To get a full understanding
of how to use (and create) effect functions, learn about the
<<effect_functions#lifecycle,Effect Function Lifecycle>>.

The effect functions need to know what lights they are supposed to
control, what capabilities they have, and how they are connected (what
universe, what channels), as well as how they are arranged in space.
This is accomplished by patching
<<fixture_definitions#fixture-definitions,Fixture Definitions>> to the
show. To work with the actual lights you have available, you will need
to create fixture definitions for them, unless they happen to be ones
already available in the Afterglow project. Since there are so many
kinds of lights, with more being created every month, that seems
unlikely unless the project really takes off… and, to that end, if you
_do_ create definitions for your lights, please contribute them to the
project!

To learn how to install Afterglow and the Open Lighting Architecture,
see the project https://github.com/brunchboy/afterglow[README].

Since Afterglow was developed to create light shows for electronic
music events, it is deeply driven by the notion of musical time,
through its <<metronomes#metronomes,Metronomes>>, so
it is worth learning how to configure and interact with them. It is
also designed to work with MIDI controllers, both to trigger effects,
and to synchronize with music, as described in
<<mapping_sync#midi-mapping-and-beat-sync,MIDI Mapping and Beat Sync>>.
