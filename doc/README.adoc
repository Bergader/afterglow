= Afterglow Documentation
James Elliott <james@deepsymmetry.org>
:icons: font

// Set up support for relative links on GitHub; add more conditions
// if you need to support other environments and extensions.
ifdef::env-github[:outfilesuffix: .adoc]

To keep page sizes manageable, this information is split into several
pages. This page provides an <<what-is-afterglow,introduction>> and
overview, and links to other sections as needed. If you know what you
are looking for, you can also dive right into it by jumping to the
page you want:

****

[horizontal]
 <<effects#effects,Effects>>::
The building blocks of a dynamic light show, which have a
<<effects#lifecycle,lifecyle>> worth understanding, and a few
<<effects#effect-examples,examples>> to get you started.

<<parameters#dynamic-parameters,Dynamic Parameters>>:: Provide inputs
to your effects which change over time and space, enabling much more
interesting and complex appearance and behavior.

<<metronomes#metronomes,Metronomes>>:: Keep track of musical time, in
terms of beats, bars, and phrases, and can be
<<mapping_sync#midi-mapping-and-beat-sync,synced>> to DJ equipment and
software.

<<oscillators#oscillators,Oscillators>>:: Convert show timing
information into waveforms that can drive your light show.

<<fixture_definitions#fixture-definitions,Fixture Definitions>>:: Tell
Afterglow how to work with different lighting hardware.

<<show_space#show-space,Show Space>>:: Explores how to measure
locations and orientations when hanging your lights so that Afterglow
can properly calculate spatial and directional effects.

<<color#working-with-color,Working with Color>>:: Introduces tools for
expressing and manipulating color values when designing lighting
effects.

<<mapping_sync#midi-mapping-and-beat-sync,Mapping and Sync>>:: Looks
at options for using MIDI controllers to run your show, and
synchronizing its metronome with DJ equipment.

<<rendering_loop#the-rendering-loop,The Rendering Loop>>:: Explains in
detail how a frame of lighting control data is calculated and sent to
the lights in the show.

****

== What is Afterglow?

Afterglow is a lighting controller designed to support
https://en.wikipedia.org/wiki/Live_coding[live coding], written in
http://clojure.org[Clojure], intended to enable people to produce
spectacular and highly customizable light shows using modern stage and
effect lighting, and which are related in deep ways to the phrasing of
music being played. (Its http://deepsymmetry.org[creator] is a DJ and
producer of light and laser shows by avocation.) Currently, the
<<effects#effects,lighting effects>> and
<<fixture_definitions#fixture-definitions,fixture definitions>> are
written and organized through Clojure code, so you will either need to
learn Clojure or work with a Clojure programmer to create new ones,
but they are controlled through MIDI control surfaces or Open Sound
Control, so once they are set up, there is great flexibility in how
you can perform them.

Someday a user interface for building shows and fixture definitions may
be created, either within Afterglow, or as a companion project, but that
is not currently planned.

NOTE: Actually, that is a bit of a fib... James has an Ableton Push
and is already exploring how to build a rich interface using its LCD
display, color-changing pressure-sensitive pads, and touch-sensitive
encoders, but that is slightly separate from the main Afterglow
project.

Afterglow communicates with the lighting hardware using the
https://www.openlighting.org/ola/[Open Lighting Architecture], so it
supports a wide variety of communication methods and interfaces.
Information about
https://github.com/brunchboy/afterglow#installation[installing OLA] is
included in the project
https://github.com/brunchboy/afterglow[README].

== How Afterglow Works

The fundamental task of Afterglow is to make light shows happen. It
does this by controlling lights, communicating with them through the
https://www.openlighting.org/ola/[Open Lighting Architecture], which
can work with several kinds of control protocols, most of which are
derived from http://en.wikipedia.org/wiki/DMX512[DMX512], or a faster
implementation of its basic ideas over Ethernet. When a show is
running, Afterglow runs a thread which periodically asks “what should
all the lights be doing now?” (resulting in a single “frame” of
control values representing that moment in time), and sends the
results of that analysis to all of the OLA universes the show is
configured to control. By default this happens thirty times each
second, but the interval is configurable within the show, and should
be decided based on the fastest refresh rate of any physical
interfaces you have hooked up to Afterglow. This is described in more
detail in the
<<rendering_loop#the-rendering-loop,Rendering Loop>> section.

TIP: In principle you could have more than one show running at a time, each
controlling a different set of OLA universes, but most people will not
need this capability.

When you just create a show and call `(show/start!)`, Afterglow will
send a bunch of zero values to the show’s universes. To make
interesting things happen you add
<<effects#effects,Effects>> to the show. The default
namespace you are put into when you launch the Afterglow project using
`lein repl` has some <<effects#effect-examples,example
effects>> that can help get a feel for this concept. To get a full
understanding of how to use (and create) effects, learn about
the <<effects#lifecycle,Effect Lifecycle>>.

The effects need to know what lights they are supposed to control,
what capabilities they have, and how they are connected (what
universe, what channels), as well as how they are arranged in space.
This is accomplished by patching
<<fixture_definitions#fixture-definitions,Fixture Definitions>> to the
show. To work with the actual lights you have available, you will need
to create fixture definitions for them, unless they happen to be ones
already available in the Afterglow project. Since there are so many
kinds of lights, with more being created every month, that seems
unlikely unless the project really takes off… and, to that end, if you
_do_ create definitions for your lights, please contribute them to the
project!

To learn how to install Afterglow and the Open Lighting Architecture,
see the project https://github.com/brunchboy/afterglow[README].

Since Afterglow was developed to create light shows for electronic
music events, it is deeply driven by the notion of musical time,
through its <<metronomes#metronomes,Metronomes>>, so
it is worth learning how to configure and interact with them. It is
also designed to work with MIDI controllers, both to trigger effects,
and to synchronize with music, as described in
<<mapping_sync#midi-mapping-and-beat-sync,MIDI Mapping and Beat Sync>>.
