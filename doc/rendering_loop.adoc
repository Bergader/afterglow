= The Rendering Loop
James Elliott <james@deepsymmetry.org>
:icons: font

// Set up support for relative links on GitHub; add more conditions
// if you need to support other environments and extensions.
ifdef::env-github[:outfilesuffix: .adoc]

When an afterglow show is running, that is, from when
http://deepsymmetry.org/afterglow/doc/afterglow.show.html#var-start.21[(show/start!)]
has been called, until
http://deepsymmetry.org/afterglow/doc/afterglow.show.html#var-stop.21[(show/stop!)]
or
http://deepsymmetry.org/afterglow/doc/afterglow.show.html#var-stop-all.21[(show/stop-all!)]
is called, there is a background task scheduled to run many times per
second, to calculate the next “frame” of control values to send to the
universes controlled by the show, and then send those values. The rate
at which this activity is scheduled is determined by the
`refresh-interval` value established when the show was
http://deepsymmetry.org/afterglow/doc/afterglow.show.html#var-show[created].
If not explicitly set as a parameter to `(show/show)`, an interval of
33⅓ milliseconds is used, causing the lights to be updated thirty times
each second. If your DMX interface is running at a different rate, you
will want to configure your show to match it, so that you are getting
the best results possible without wasting computation on frames that
never get seen.

TIP: Once a show has started running, you can get a sense of how heavily it
is taxing your hardware by looking at the show’s `:statistics` atom:

[source,clojure]
----
@(:statistics *show*)
; -> {:afterglow-version "0.1.0-SNAPSHOT",
; ->  :total-time 70429,
; ->  :frames-sent 105828,
; ->  :average-duration 0.6655044,
; ->  :recent #amalloy/ring-buffer [30 (0 0 0 0...1 0 0 0 0 0 0 1 0 0 1)],
; ->  :recent-total 6,
; ->  :recent-average 0.2}
; -> ----
____
This tells you how many milliseconds have been spent in the rendering
loop while the show is running, how many frames of DMX data have been
sent to the show universes, and the average number of milliseconds spent
in the rendering loop. If the duration of a rendering cycle ever exceeds
the refresh interval, Afterglow will log a warning that it is unable to
keep up with the effects you are trying to run.

If you have a show&rsquo;s web interface open, the `:recent` keys in
this atom are used to display the Load bar at the top of the screen,
which fills up and turns red as the time within each frame available
for calculating and sending control values to the lights gets used up.
____

When it is time to determine the next set of values to send to the
show’s patched fixtures, this is what happens:

. The first thing Afterglow does is take a
http://deepsymmetry.org/afterglow/doc/afterglow.rhythm.html#var-ISnapshot[snapshot]
of the show
https://github.com/brunchboy/afterglow/wiki/Metronomes[metronome] to
identify a common point in time for all the effects to use in deciding
how they should look. This enables a consistent, coordinated appearance
for everything in the frame.

. The next step is to zero out the buffers that will be used to send
DMX data for each universe, so that if no effect tries to set a value
for a particular channel on this frame, a zero value will be sent for
it.

. Then Afterglow loops over all
<<effects#effects,Effects>> that are currently active
for the show, and asks if any are ready to end, as described in the
<<effects#lifecycle,Effect Lifecycle>> section. If any are,
they are removed from the list of active effects.

. Then it makes another loop over any effects that did not end, to see
how they want to affect the lights. It does this by calling, in order,
each effect’s
http://deepsymmetry.org/afterglow/doc/afterglow.effects.html#var-generate[generate]
function, passing in the show and the metronome snapshot. In order to
make the lights do things, each effect returns a list of
<<rendering_loop#assigners,Assigners>> specifying the things it wants
to happen. These are gathered in the order they were returned by each
effect. Since the effects are run in priority order (lower priority
first, with effects of the same priority running in the order in which
they were added to the show), higher-priority and more recent effects’
assigners will get the chance to modify or veto any assigners from
earlier and lower-priority effects which are trying to control the
same thing. If the effect doesn’t want to do anything this frame, it
can simply return an empty assigner list.

. Once all the assigners have been collected, Each assigner’s
http://deepsymmetry.org/afterglow/doc/afterglow.effects.html#var-assign[assign]
function is called, again passing in the show and the metronome
snapshot, the target which is being assigned (a DMX channel in a show
universe, or a fixture or fixture head, depending on the assigner
type), as well as the assignment value the effect wanted to establish
(a number, color, or head direction, again depending on the assigner
type), and the previous assignment (if any) that an earlier assigner
wanted to set for this target. The assigner can decide what to do with
the previous assignment: Ignore it, blend the current assignment with
it somehow, or honor it, depending on the nature and configuration of
the assigner. The `assign` function returns a single resolved value of
the appropriate type for the assignment, and Afterglow records it,
potentially to pass it to another assigner of the same type which
wants to affect the same target. The assigner can also veto any
previous assignment and say that nothing should happen by returning
`nil`. + The input to `assign` might be a
<<parameters#dynamic-parameters,Dynamic Parameter>>, and the return
value may be as well, or the assigner may choose to resolve it into a
non-dynamic value, in order to decide between or blend competing
assignments. + At the end of this process, Afterglow is left with a
single assigned value for every target which any effect wanted to
influence for the current frame.

. Afterglow uses these assignment results to establish actual DMX
values for the frame. It splits them based on the kind of assignment
they want to make, doing all of one type before moving on to the next
type. The type ordering is established by
http://deepsymmetry.org/afterglow/doc/afterglow.show.html#var-resolution-handlers[show/resolution-handlers]
and starts with low-level, single channel `:channel` assigners, then
moves up to more complex `:function`, `:color`, and `:direction`
assigners. The resolution-handler functions finally resolve any
remaining dynamic parameters, and then turn abstractions like color
objects into appropriate DMX channel values for the target that is being
assigned.

. Finally, the resulting buffers of DMX values, with zeros in any
channels which were not affected by assigners, are sent to their
corresponding universes, causing the lights to produce the desired
effects.

[[assigners]]
Assigners
~~~~~~~~~

TODO: Flesh out

[[channel-assigners]]
Channel Assigners
^^^^^^^^^^^^^^^^^

[[function-assigners]]
Function Assigners
^^^^^^^^^^^^^^^^^^

[[color-assigners]]
Color Assigners
^^^^^^^^^^^^^^^

[[direction-assigners]]
Direction Assigners
^^^^^^^^^^^^^^^^^^^

[[aim-assigners]]
Aim Assigners
^^^^^^^^^^^^^
