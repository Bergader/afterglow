= Effects
James Elliott <james@deepsymmetry.org>
:icons: font
:toc:
:toc-placement: preamble

// Set up support for relative links on GitHub; add more conditions
// if you need to support other environments and extensions.
ifdef::env-github[:outfilesuffix: .adoc]

Effects determine what a light or group of lights are doing at a given
moment in time.

== Overview

When creating an effect, you assign one or more
<<fixture_definitions#fixture-definitions,Fixtures>> to it, and it
will generate control values for only those fixtures. The fixture
channels affected by the effect depend on the kind of effect it is,
and are grouped into several primary categories. The simplest kinds of
effects apply to a single channel per fixture, or perhaps per head, if
the fixture has multiple independent light-emitting heads. A very
common single-channel effect is the <<dimmer-effects,dimmer effect>>.

Many effects assign <<color-effects,colors>> to lights, which often
involves multiple channels. RGB fixtures will use three channels, one
each for the red, green, and blue levels which make up the color. Some
fixtures add other LED colors, such as amber, white, and even
ultraviolet. Other fixtures simply use a rotating color wheel to pick
from a fixed set of colors, using a single channel. Regardless of how
the color is finally produced, at most stages of effect processing,
Afterglow works in terms of the
<<working_with_color#working-with-color,color itself>>, allowing you
to blend, lighten, darken, shift hue, and the like so you can produce
interesting looks, without regard to details of fixture
implementation. It is only at the
<<rendering_loop#the-rendering-loop,final rendering stage>> that the
color is broken down into channel assignments.

Another important category of effects control the
<<direction-effects,direction>> of moving-head fixtures. These work in
terms of a desired 3D direction vector or <<aim-effects,target point>>
with respect to the <<show_space#show-space,show frame of reference>>,
and at the last stage of rendering, convert that to pan and tilt
channel values, with reference to the angle at which the fixture has
actually been hung.

You can also conveniently use features which are shared by a number of
fixtures, or completely unique to a single fixture, through
<<function-effects,function effects>>, or drop right down to the
level of individual DMX channel values with
<<channel-effects,channel effects>>.

Finally, Afterglow includes some examples of how to build up
<<complex-effects,special-purpose effects>>, which can be fun in
themselves, and also serve as templates and inspiration for whole new
kinds of effects you create on your own.

== Effect Types

Effects in afterglow are divided by the aspect of a light that they
control. Not all fixtures have features which allow them to
participate in all kinds of effects. Afterglow effects will
simply ignore fixtures which are unable to reapond to them.

=== Dimmer Effects

Dimmer effects set the basic brightness level of a fixture. To create
an effect that will set the dimmer level of a fixture, use:

[source,clojure]
----
(afterglow.effects.dimmer/dimmer-cue level fixtures htp?)
----

This effect finds all the dimmer channels associated with the specified
fixtures (there may be multiple, if the fixture has more than one
light-emitting head), and assigns them a level. 0 is off, 255 is maximum
brightness. If `htp?` is true, uses highest-takes-precedence rules when
replacing any earlier or lower-priority effects which attempted to set
this particular dimmer in the current rendering cycle. In other words,
if an earlier effect chose a higher value, let it win, otherwise use the
value this effect wants. If `htp?` is false, this effect will simply
overwrite any previous assignments it finds for the dimmers it is
controlling. Omitting `htp?` is the same as passing a `true` value.

TIP: If you want your dimmer cue to affect only one head of a fixture, you
can pass it just that head, rather than the entire fixture.

For some fixtures, generally those with a single, white light source,
the dimmer is the only thing that determines the amount of light output.
For color-mixing fixtures like RGB LED lights, each color channel has
its own separate brightness level, and then dimmer scales the actual
output of the light, so the final brightness will be a combination of
both. In other words, if the red channel is set to 50% brightness, and
the dimmer is also set to 50% brightness, the final red output will be
at 25% brightness.

In addition to passing in a literal number for the `level` parameter,
you can pass a [[Dynamic Parameter|dynamic parameters]] whose value
depends on a [[Metronome|metronomes]], the physical location or
orientation of the head, or a show variable, perhaps
[[bound|midi-mapping-and-beat-sync#mapping-a-control-to-a-variable]] to
a MIDI control surface. It often makes sense to use [[oscillated
parameters|dynamic-parameters#oscillated-parameters]] with dimmer cues.

TIP: If you have color effects running for a light and you aren’t seeing
anything, make sure you have a dimmer effect setting the dimmer to some
visible level.

=== Color Effects

One of the most common basic effects you will be using to create the
looks you want is the color cue. To create an effect that will assign a
color to a fixture (which will assign colors to all of the fixture’s
heads), or a single head of a fixture, pass the fixture or head to:

[source,clojure
----
(afterglow.effects.color/color-cue name color fixtures)
----

The `name` parameter is intended to help identify the purpose of the
effect, and shows up when examining the created effect. Put something
descriptive in there, or use a function like
`afterglow.examples/global-color-effect` which builds the cue for you,
figuring out a reasonable name in many cases.

The `color` parameter is where you specify the color to assign to the
lights. It can be a string, specifying the name of a color understood by
the https://github.com/jolby/colors[jolby/colors] library, or an object
returned by one of the factories in that library as described in
<<color#working-with-color,Working with Color>>.

In addition to passing in a literal number for the `color` parameter,
you can pass a <<parameters#dynamic-parameters,Dynamic Parameter>>
whose value depends on a <<metronomes#metronomes,Metronome>>, the
physical location or orientation of the head, or a show variable,
perhaps <<mapping_sync#mapping-a-control-to-a-variable,bound>> to a
MIDI control surface. The flexibility offered by
<<parameters#color-parameters,dynamic color parameters>> is huge,
especially when combined with
<<parameters#oscillated-parameters,oscillated parameters>>. Learning
how to effectively leverage these in combination with each other will
enable you to create most of the basic lighting looks you need.

TIP: Remember that if aren’t seeing anything when you have assigned color
effects to a fixture to make sure you also have a dimmer effect setting
that fixture’s dimmer to some visible level.

=== Direction Effects

Moving-head fixtures can create particularly exciting and dynamic shows.
To create an effect that will tell a fixture or head what direction it
should be pointing, pass the fixture or head to:

[source,clojure]
----
(afterglow.effects.movement/directon-cue name direction fixtures)
----

The `name` parameter is intended to help identify the purpose of the
effect, and shows up when examining the created effect.

The `direction` parameter is where you specify the direction the
lights should be pointing. It is a `javax.vector.Vector3d` pointing in
the direction the lights should, with respect to the show’s
<<show_space#show-space,frame of reference>>. An easy way to create
one is to call
http://deepsymmetry.org/afterglow/doc/afterglow.effects.params.html#var-build-direction-param[afterglow.effects.params/build-direction-param].
This can create static vectors for you, but can also create
<<parameters#dynamic-parameters,Dynamic Parameters>> whose value
depends on a <<metronomes#metronomes,Metronome>>, the physical
location or orientation of the head, or a show variable, perhaps
<<mapping_sync#mapping-a-control-to-a-variable,bound>>
to a MIDI control surface. Building dynamic direction parameters with
<<parameters#oscillated-parameters,oscillated parameters>> can
create fascinating motions.

=== Aim Effects

These are very similar to <<direction-effects,direction effects>>,
except they tell each fixture to aim at a particular point in space,
such as an object or person in front of the lighting rig, or perhaps
another fixture. To create an effect that will tell a fixture or head
what point it should be aiming at, pass the fixture or head to:

[source,clojure]
----
(afterglow.effects.movement/aim-cue name target-point fixtures)
----

The `name` parameter is intended to help identify the purpose of the
effect, and shows up when examining the created effect.

The `target-point` parameter is where you specify the point at which
the lights should be aiming. It is a `javax.vector.Point3d`
identifying a point within the show’s <<show_space#show-space,frame of
reference>>. An easy way to create one is to call
http://deepsymmetry.org/afterglow/doc/afterglow.effects.params.html#var-build-aim-param[afterglow.effects.params/build-aim-param].
This can create static points for you, but can also create
<<parameters#dynamic-parameters,Dynamic Parameters>> whose value
depends on a <<metronomes#metronomes,Metronome>>, the physical
location or orientation of the head, or a show variable, perhaps
<<mapping_sync#mapping-a-control-to-a-variable,bound>> to a MIDI
control surface. Using a tablet with an OSC or midi interface that
lets you drag an aiming point around a map of the stage is one fun
possibility.

=== Function Effects

Fixtures have a wide variety of different capabilities, often more
than would be reasonable to assign a separate DMX channel for each,
especially when it does not make sense to activate or control some at
the same time. Afterglow can be told about these in the
<<fixture_definitions#fixture-definitions,fixture definition>>, and
you can control them using function effects, by specifying the name of
the function you want to activate, and a percentage by which you want
it activated (representing the value within that function’s valid DMX
range that you want Afterglow to send).

For example, many fixtures have a strobe function, which causes them to
flash off and on at a particular speed. The following line shows how to
cause them all to strobe at their fastest speed:

[source,clojure]
----
(show/add-effect! :strobe (afterglow.effects.channel/function-cue
  "Fastest strobe" :strobe 100 (show/all-fixtures)))
----

With this effect active, any fixture with a `:strobe` function range
will be sent the highest value defined for that range, on the channel on
which the function exists, causing it to strobe rapidly. Fixtures which
lack such a function will be unaffected.

Function effects can be very specific to individual fixtures. For
example, the Blizzard Torrent F3 has a pair of gobo wheels; one of them
has a gobo that projects something that looks like a fat atom with
electrons orbiting it. This projection can be selected, and caused to
jiggle back and forth at the mid-range of possible shake speeds, by
adding the following effect:

[source,clojure]
----
(show/add-effect! :gobo-fixed
  (afterglow.effects.channel/function-cue "Brownian motion?"
    :gobo-fixed-atom-shake 100 (show/fixtures-named "torrent")))
----

Depending on how far away the projection is landing, it may be very
blurry; focus can be adjusted like so:

[source,clojure]
----
(show/add-effect! :focus
  (afterglow.effects.channel/function-cue
    "focus" :focus 95.5 (show/fixtures-named "torrent")))
----

The functions available for a fixture, their names, channels, and
ranges, are specified by the
<<fixture_definitions#fixture-definitions,fixture definition>>, so
reading over those can be helpful. (And carefully crafting and testing
them is important when defining a new fixture.) Trying to maintain
consistency in function naming is valuable in allowing functions to be
conveniently applied to groups of different fixtures.

Functions which do not vary in their effect for different DMX values
within the legal range are described as `:range :fixed` in the fixture
definition; this is currently only used for displaying the
interpretation of a fixture setting, you still need to provide a
percentage within the range when setting up the function effect.

Fixture definitions can also supply a _scaling function_ for a function
specification, which maps input values to the final percentage within
the DMX range. This is helpful, for example, to allow strobe settings to
be interpreted as approximate Hz values, so fixtures from different
manufacturers can be asked to strobe at roughly the same rate for the
same function setting. You can view the source of the
http://deepsymmetry.org/afterglow/doc/afterglow.fixtures.blizzard.html[Blizzard
fixture definitions] for examples of how this is done, passing the
minimum and maximum Hz strobe rates of the actual fixture to create a
partial implementation of
http://deepsymmetry.org/afterglow/doc/afterglow.effects.channel.html#var-function-value-scaler[afterglow.effects.channel/function-value-scaler]
which is passed the value that the effect is trying to establish, and
converts it to a position in that fixture’s range which attempts to
approximate that strobing rate.

=== Channel Effects

When you just want to send a specific number to a particular DMX
channel, you can drop right down to the bottom level with channel
effects. For example, to pin the dimmer channel of a group of fixtures
to 55, regardless of the setting of the show’s master chain, you could
do something like this:

[source,clojure]
----
(show/add-effect! :blade-dimmers
  (afterglow.effects.channel/channel-cue "Blade dimmers" 55
    (afterglow.channels/extract-channels
      (show/fixtures-named :blade) #(= (:type %) :dimmer))))
----

Or to look at what actual pan values do to a Torrent, without fancy
geometric transformations, as you set values into the show variable
named `:pan`:

[source,clojure]
----
(show/add-effect! :pan-torrent
  (afterglow.effects.channel/channel-cue
    "Pan Torrent" (params/build-variable-param :pan)
    (afterglow.channels/extract-channels
      (show/fixtures-named :torrent) #(= (:type %) :pan))))
----

You will most likely be wanting to do this sort of thing for channel
types which Afterglow does not yet have a more sophisticated
understanding, and then perhaps you will end up creating a whole new
category of effects as your experimentation progresses.

=== Complex Effects

These are effects which build on more than one of the capabilities
listed above to create an interesting or fun effect. They represent
examples of how Afterglow can be used to create new things, and we
hope that people will contribute their own effects for inclusion in
future releases.

==== Metronome

The Metronome cue is a great way to check the synchronization of the
show metronome with your DJ software or mixer, and is a nice example of
how to write a cue that is driven by a metronome.

[source,clojure]
----
(afterglow.effects.color/metronome-cue fixtures
  :down-beat-color color1 :other-beat-color color2)
----

Creates an effect which flashes the heads of the supplied fixtures one
color on the down beat and another color on the other beats of the
show metronome. The two color keyword parameters are optional; if they
are omitted, the down beat color is a lightened red, and the other
beat color is a darkened yellow.

==== Sparkle

To be documented shortly!

[[lifecycle]]
== The Effect Lifecycle

When an effect is added to a show via `(show/add-effect! :keyword
effect-fn priority)` it immediately replaces any other effect which
had been previously added with the same keyword. The former effect
does not get a chance to gracefully finish its effects, it is simply
gone. The new effect is added to the
<<rendering_loop#rendering-loop,rendering loop>> in a position
determined by the priority value. If no priority argument is supplied,
a priority of zero is defaulted in. The new effect is added after any
other existing effects of the same (or lower) priority, but before any
existing effects with higher priority. Since later effects get a
chance to override earlier effects, this means that higher-priority
effects, and effects added later, win.

All effecta implement the
http://deepsymmetry.org/afterglow/doc/afterglow.effects.html#var-IEffect[afterglow.effects/IEffect]
protocol. As each frame of lighting control values is rendered, a
snapshot is created from the show metronome, so every effect shares the
same notion of the point in time at which effects are being rendered.
The priority-ordered list of effects is traversed, and each effect’s
`(still-active? [this show snapshot])` function is invoked to determine
if the effect has ended at this point. If this returns `true`, the
effect is removed from the list of active effects, and is finished.
Limited-time effects can use this mechanism to tell the show when they
finish. Ongoing effects will simply always return `true`, or if they
want to end gracefully, will return `true` until they have been asked to
end, and their graceful ending has completed.

Assuming the effect has not reported completion, its
`(generate [this show snapshot])` function will be called, as described
in the [[rendering loop|rendering-loop]] section, to create the effect
it represents at this point in time.

At some point, the show operator may indicate a desire for the effect to
end, by calling `(show/end-effect! :keyword force)`. If `force` is true,
the effect will simply be removed from the list of active effects. If it
is omitted or false, the effect is asked to end gracefully by calling
its `(end [this show snapshot])` function. If the effect is ready to end
right away, it can return `true`, and will be removed at that point.
Otherwise, if it wants to take a little while to animate an ending
effect, it should set an internal flag so it knows it is ending and
return `false`, and at some point in the not-so-distant future, conclude
its ending and return `false` from `still-active?`.

If `end-effect!` is called a second time for an effect which was already
asked to end, even if `force` is false, it will be removed forcibly at
that point.

== Effect Examples

Here are a few ways in which effects can be used and combined.

NOTE: These examples assume you are in a Clojure REPL with Afterglow loaded,
in the namespace `afterglow.examples`. This is the default namespace you
get if you check out the project and run `lein repl`.


=== Oscillator Effects

Oscillators in Afterglow are a flexible way of turning the timing
information tracked by metronomes into waveforms that can be used to
make lights do interesting things. They can be related to the beats or
bars of the metronome, or multiples or fractions thereof, and can be
sawtooth, triangle, square, or sine waves.
http://en.wikipedia.org/wiki/Sawtooth_wave[Wikipedia] has a nice
introduction to these waveforms. The namespace
`afterglow.effects.oscillator` has
<<oscillators#oscillators,functions>> for creating lots of variations
on them.

Here is one way to create a basic oscillated hue effect which cycles
through all colors over one bar of the show metronome:

[source,clojure]
----
(def hue-param (params/build-oscillated-param
                 (oscillators/sawtooth-bar) :max 360))
(show/add-effect! :color (global-color-effect
   (params/build-color-param :s 100 :l 50 :h hue-param)))
----

TIP: Remember that if you aren’t seeing anything when after assigning color
effects to a fixture to make sure you also have a dimmer effect setting
that fixture’s dimmer to some visible level.

We can set up separate metronomes as show variables, so that effect
timing can be separate from the main show, which is intended to track
the beat of the music. Here we will create a metronome running at 5
beats per minute in a show variable we will call `timer`.

[source,clojure]
----
    (show/set-variable! :timer (metronome 50))
----

Then we can build an oscillated hue parameter based on that timer, for a
nice, gradual color fade. We will use a sawtooth wave since it smoothly
goes from its minimum to its maximum value. Zero is the default minimum,
which is perfect, since it is the lowest hue value. We will tell the
oscillated parameter to range from that to a maximum of 360, the largest
hue. Since hues form a circle, we will fade smoothly around the circle
for each oscillation, with no jarring transition from one bar to the
next:

[source,clojure]
----
(show/set-variable! :hue-param
  (params/build-oscillated-param (oscillators/sawtooth-bar)
    :metronome :timer :max 360))
----

Notice the use of the keyword `:timer` to tell `build-oscillated-param`
to use the show variable with that name for its `:metronome` keyword
parameter. We can do the same thing when building our color effect to
use this oscillated hue parameter variable:

[source,clojure]
----
(show/add-effect! :color (global-color-effect
  (params/build-color-param :s 100 :l 50 :h :hue-param)))
----

We can change the speed of the fade by changing the BPM of the
metronome stored in the show variable:

[source,clojure]
----
(metro-bpm (show/get-variable :timer) 500)
----

Suddenly it is crazy fast!

[source,clojure]
----
(metro-bpm (show/get-variable :timer) 5)
----

Back to a sedate fade.

=== Spatial Effects

Rather than spreading the rainbow out in time, how about if we spread it
physically across the lights in the show, in the form of a rainbow
gradient along the X axis?

[source,clojure]
----
(def hue-gradient (params/build-spatial-param (show/all-fixtures)
  (fn [head] (- (:x head) (:min-x @(:dimensions *show*)))) :end 360))
(show/add-effect! :color (global-color-effect
  (params/build-color-param :s 100 :l 50 :h hue-gradient)
                            :include-color-wheels true))
----

NOTE: Since this cue is not constantly changing over time, it makes
sense to allow fixtures that use color wheels to participate.

That’s pretty! But now that we have both of these interesting concepts,
oscillators and spatial gradients, wouldn’t it be nice if we could
combine them? Oh, but we can!

[source,clojure]
----
(def adjust-param
  (params/build-oscillated-param (oscillators/sawtooth-bar) :max 360))
(show/add-effect! :color (global-color-effect
  (params/build-color-param :s 100 :l 50 :h hue-gradient
                            :adjust-hue adjust-param)))
----

NOTE: Now the rainbow drifts across the whole lighting rig. We left out color
wheels this time, since the color is continually shifting.

The <<effect-types,Effect Types>> section goes into more
detail about how these effects work.
