= MIDI Mapping and Beat Sync
James Elliott <james@deepsymmetry.org>
:icons: font
:experimental:

// Set up support for relative links on GitHub; add more conditions
// if you need to support other environments and extensions.
ifdef::env-github[:outfilesuffix: .adoc]

Afterglow is designed to work with MIDI controllers and DJ equipment.
You can bind physical controller elements to trigger cues and adjust
show variables, and sync the BPM of the show master metronome to MIDI
clock pulses from a DJ controller or mixer. (Although if you have
professional Pioneer gear, you are better off syncing the metronome to
the Pro DJ Link via an Ethernet cable.)

NOTE: These examples assume you are in a Clojure REPL with Afterglow loaded,
in the namespace `afterglow.examples`. This is the default namespace you
get if you check out the project and run `lein repl`. The sample show is
assumed to be running; if not, `(show/start!)`

== Mapping Cues to a Controller

Although the most convenient and powerful way of running cues with
Afterglow is to use a large grid controller with color feedback, like
the Ableton Push which can mirror the cue grid of the web interface,
you can still accomplish a great deal with a simple controller with a
few buttons. You will still want to start by creating the cues in the
show cue grid, not only so you can see and manipulate them with the
web interface, but also because that is how they can be mapped to MIDI
controllers.

First you need to identify the MIDI messages that the controller sends
when you press and release the interface element you want to assign
the cue. Afterglow can help with that too, as described
<<finding-mapping-details,below>>. Once you have the cue created and
the control identified, you can create the mapping using
http://deepsymmetry.org/afterglow/doc/afterglow.show.html#var-add-midi-control-to-cue-mapping[afterglow.show/add-midi-control-to-cue-mapping], like:

[source,clojure]
----
(show/add-midi-control-to-cue-mapping "nano" 0 :control 46 0 6)
----

This would cause Afterglow to start or stop the cue at grid position
(0, 6) when a pad on the device named "nano" is pressed and sends a
MIDI control change message on control number 46.

If the controller has LEDs associated with the controls, and you can
configure it so that its LEDs are in external control mode, Afterglow
will even give you feedback about when the cue is running, by lighting
up the pad or button when the cue starts (whether or not you started
it using this controller), and darkening it when the cue ends.

== Mapping a Control to a Variable

You can also tie an encoder or fader on a MIDI control surface to a
show variable, so that turning the encoder or sliding the fader
changes the value of the variable. If you have set up cues to look at
that variable, through
https://github.com/brunchboy/afterglow/blob/master/doc/cues.adoc#cue-variables[cue-specific
variable bindings], the control surface can then vary the look of the
effect created by the cue, both before the cue is launched, and while
it is running.

Here is a lower-level example of how I can have a knob on one of my
simple MIDI controllers set the hue of all the lights. It shows up
with a MIDI port name of `SLIDER/KNOB`, and its first rotary
controller is control 16 on channel 0. I can map that to set a show
variable `knob-1` to the values 0-360 (the legal hue values):

[source,clojure]
----
(show/add-midi-control-to-var-mapping
  "Slider" 0 16 :knob-1 :max 360)
----

Then I can create a global color effect based on that variable:

[source,clojure]
----
(show/add-effect! :color (global-color-effect
  (params/build-color-param :s 100 :l 50 :h :knob-1)))
----

== Finding Mapping Details

In the all-too likely event you don’t have all your MIDI port names and
control channel and note numbers memorized, Afterglow can help. Just
run...

[source,clojure]
----
(afterglow.midi/identify-mapping)
----

...then twiddle the knob, slide the fader, or press the button you
wish to map. Afterglow will report the first control-change or note
message it receives:

[source,clojure]
----
; -> {:command :control-change, :channel 0, :note 32, :velocity 127,
;     :device {:name "SLIDER/KNOB",
;              :description "nanoKONTROL2 SLIDER/KNOB"}}
----

____
Notice that even for control changes, the controller number is
identified as `:note` (32 in this example).
____

If nothing is received for ten seconds, it will give up:

[source,clojure]
----
; -> nil
----

If this happens, remember that you need to have all of your MIDI devices
hooked up before you start Afterglow, because of limitations in the Java
MIDI implementation. Try quitting and restarting Afterglow. If that
doesn’t help, you will need to troubleshoot your MIDI setup.

NOTE: These examples show how to perform low-level MIDI mapping. Over
time, you might find that someone has written a rich user interface
binding for your controller, as is happening for the
http://deepsymmetry.org/afterglow/doc/afterglow.controllers.ableton-push.html[Ableton
Push], which would let you jump right in without having to worry about
such details. These examples can still help explain how your
controller's binding works, or encourage you to write and share a
binding for a new controller that you happen to have.

== Syncing to MIDI Clock

Many DJ mixers automatically send MIDI clock pulses to help synchronize
to their BPM. Pioneer’s Nexus mixers send MIDI clock over both their
physical MIDI connection, and over USB if you are connected that way,
conveniently. But they offer far more useful sync information over the
Ethernet port via Pro DJ Link packets, which Afterglow
<<syncing-to-pro-dj-link,can also process>>.

If you are using a mixer or DJ software like Traktor which supports only
MIDI clock sync, it is a lot better than nothing! Here is how to take
advantage of it.

TIP: Native Instruments has an informative Knowledge Base article
which
http://www.native-instruments.com/en/support/knowledge-base/show/750/how-to-send-a-midi-clock-sync-signal-in-traktor/[explains]
how to configure Traktor to send the MIDI clock pulses that Afterglow
can sync to.

Once you have your MIDI clock pulses reaching the system on which
Afterglow is running, start Afterglow. Because of limitations inherent
in the Java MIDI API, only MIDI devices which were connected when the
program started are available to it. Then, assuming you have only one
device sending MIDI clock, you can just execute:

[source,clojure]
----
(show/sync-to-external-clock (afterglow.midi/sync-to-midi-clock))
----

If there is ambiguity about which device’s MIDI clocks you want to
process, Afterglow will complain. Resolve that by passing a substring
which uniquely matches the name or description of the MIDI device that
you want to sync to:

[source,clojure]
----
(show/sync-to-external-clock
  (afterglow.midi/sync-to-midi-clock "traktor"))
----

From then on, as the BPM of that device changes, Afterglow will track it
automatically. To check on the sync status, you can invoke:

[source,clojure]
----
(show/sync-status)
; -> {:type :midi, :status "Running, clock pulse buffer is full."}
----

The calculated BPM of the synced show can be displayed like this:

[source,clojure]
----
(metro-bpm (:metronome sample-show))
; -> 128.5046728971963
----

It will bounce up and down near the actual BPM as clock pulses are
received, but overall track the beat quite well. To get a rock-solid
beat lock you need to have equipment that can provide Pro DJ Link
syncing, as described below.

To shut down the syncing, just call `sync-to-external-clock` with no
sync source:

[source,clojure]
----
(show/sync-to-external-clock)
(show/sync-status)
; -> {:type :manual}
----

== Syncing to Pro DJ Link

If you are working with Pioneer club gear, such as the Nexus line of
CDJs and mixers, you can use Pro DJ Link to sync much more precisely.
You just need to be on the same LAN as the gear (most easily by
connecting an Ethernet cable between your laptop running Afterglow and
the mixer, or a hub or router connected to the mixer. You don’t need to
be connected to the Internet, the protocol works fine over self-assigned
IP addresses. You just need to specify which device you want to use as
the source of beat information, and that will generally be the mixer,
since it will track whichever device is currently the tempo master (or
perform BPM analysis if a non-DJ-Link, or even non-digital, source is
being played). Like with MIDI sync, you can give a unique substring of
the device name in the sync call:

[source,clojure]
----
(show/sync-to-external-clock
  (afterglow.dj-link/sync-to-dj-link "DJM-2000"))
----

As with MIDI, you can check on the sync status:

[source,clojure]
----
(show/sync-status)
; -> {:type :dj-link, :status "Running, 5 beats received."}
; -> {:type :dj-link,
;     :status "Network problems? No DJ Link packets received."}
----

TIP: If you are not getting any packets, you will need to put on your
network troubleshooting hat, and figure out why UDP broadcast packets
to port 50001 from the mixer are not making it to the machine running
Afterglow.


= Checking your Sync

An easy way to see how well your show is syncing the beat is to use the
`metronome-effect`, which flashes a bright pink pulse on the down beat, and a
less bright yellow pulse on all other beats of the show metronome. To
set that up:

[source,clojure]
----
(require 'afterglow.effects.fun)
(show/add-effect! :color
  (afterglow.effects.fun/metronome-effect (show/all-fixtures)))
----

Then you can reset the metronome by hitting kbd:[Return] on the following
command, right on the down beat of a track playing through your
synchronized gear, and watch how Afterglow tracks tempo changes made by
the DJ from then on:

[source,clojure]
----
(metro-start (:metronome sample-show) 1)
----

When running live light shows you will almost certainly want to map a
button on a MIDI controller to perform this beat resynchronization
(although it is not necessary when you are using Pro DJ Link to
synchronize with your mixer—but even then you will likely want the next
two functions mapped, for realigning on bars and phrases). Here is how I
do it for one of the buttons on my Korg nanoKontrol 2:

[source,clojure]
----
(show/add-midi-control-metronome-reset-mapping "slider" 0 45)
----

Then, whenever I press that button, the metronome is started at beat 1,
bar 1, phrase 1.

You can add mappings to reset metronomes which are stored in show
variables by adding the variable name as an additional parameter at the
end of this function call. And there is a corresponding
`remove-midi-control-metronome-mapping` function to break the binding.

As noted above, even when you have a rock solid beat sync with your
mixer, you sometimes want to adjust when bars or phrases begin,
especially when tricky mixing has been taking place. You can accomplish
this by mapping other buttons with
`add-midi-control-metronome-align-bar-mapping` and
`add-midi-control-metronome-align-phrase-mapping`. These cause the MIDI
control to call `metro-bar-start` and `metro-phrase-start` on the
associated metronome to restart the current bar or phrase on the nearest
beat, without moving the beat. This means you do not need to be as
precise in your timing with these functions, so you can stay beat-locked
with your synch mechanism, much like the “beat jump” feature in modern
DJ software.

If the metronome flashes start driving you crazy, you can switch back to
a static cue,

[source,clojure]
----
(show/add-effect! :color blue-effect)
----

or even black things out:

[source,clojure]
----
(show/clear-effects!)
----
